generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Hoặc mysql/sqlite
  url      = env("DATABASE_URL")
}

// 1. USER & AUTH
enum UserRole {
  USER
  PARTNER
  ADMIN
  SUPER_ADMIN
}

model User {
  id       String   @id @default(cuid())
  name     String?
  email    String   @unique
  password String?
  role     UserRole @default(USER)
  image    String?

  points        Int       @default(0)
  emailVerified DateTime?

  accounts Account[]
  sessions Session[]

  bookings       Booking[]
  flightBookings FlightBooking[]
  hotels         Hotel[]

  vouchers  Voucher[]
  blogPosts BlogPost[]
  aiConversations AiConversation[]
  partnerApplications PartnerApplication[]
  
  // AI Features
  profile              UserProfile?
  consent              UserConsent?
  behaviorPattern      BehaviorPattern?
  interactions         UserInteraction[]
  conversationSessions ConversationSession[]
  roomHolds            RoomHold[]
  proactiveSuggestions ProactiveSuggestion[]
  priceWatches         PriceWatch[]
  autoActionLogs       AutoActionLog[]
  
  // Enterprise AI System
  aiDelegation       AIDelegation?
  draftBookings      DraftBooking[]
  draftCancellations DraftCancellation[]
  aiTaskLogs         AITaskLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// 2. KHÁCH SẠN & BẢN ĐỒ
model Hotel {
  id          String   @id @default(cuid())
  name        String
  city        String
  address     String
  description String   @db.Text
  images      String[]
  rating      Float    @default(0)
  status      String   @default("ACTIVE")
  businessTags String[] @default([]) // AI taxonomy: business_friendly, near_airport, family_safe, honeymoon_ready, etc.

  latitude  Float @default(11.940419)
  longitude Float @default(108.458313)

  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id])

  rooms    Room[]
  bookings Booking[]
  priceWatches PriceWatch[]
  draftBookings DraftBooking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Room {
  id          String @id @default(cuid())
  hotelId     String
  name        String
  description String
  price       Float

  capacity  Int @default(2)
  maxGuests Int @default(2)
  quantity  Int @default(1)

  images    String[]
  amenities String[]

  hotel       Hotel           @relation(fields: [hotelId], references: [id], onDelete: Cascade)
  bookings    Booking[]
  inventories RoomInventory[]
  priceHistory PriceHistory[]
  holds        RoomHold[]
  draftBookings DraftBooking[]
}

// 3. BOOKING & FLIGHT
enum BookingStatus {
  // PENDING means: created but not yet confirmed (typically awaiting payment).
  // We keep this value for backwards compatibility with existing UI and data.
  PENDING
  // PENDING_PAYMENT is a more explicit variant used by the new payment flow.
  // Existing UI that simply prints the status string will still work.
  PENDING_PAYMENT
  CONFIRMED
  CANCELLED
}

// --- BLOG / CẨM NANG ---
enum BlogStatus {
  DRAFT
  PUBLISHED
  PENDING_REVIEW
}

enum AttractionStatus {
  DRAFT
  PUBLISHED
}

model Booking {
  id      String @id @default(cuid())
  userId  String
  hotelId String
  roomId  String
  voucherId String?

  checkIn       DateTime
  checkOut      DateTime
  originalPrice Float
  discount      Float    @default(0)
  totalPrice    Float

  paymentMethod String        @default("PAY_AT_HOTEL")
  status        BookingStatus @default(PENDING)

  guestName  String?
  guestPhone String?
  note       String?

  user    User     @relation(fields: [userId], references: [id])
  hotel   Hotel    @relation(fields: [hotelId], references: [id])
  room    Room     @relation(fields: [roomId], references: [id])
  voucher Voucher? @relation(fields: [voucherId], references: [id])
  payment Payment?
  draftCancellations DraftCancellation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([hotelId])
  @@index([roomId])
  @@index([status])
  @@index([voucherId])
}

model BlogPost {
  id         String     @id @default(cuid())
  title      String
  slug       String     @unique
  excerpt    String?
  content    String     @db.Text
  coverImage String?
  status     BlogStatus @default(DRAFT)

  authorId String
  author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([authorId])
}

model Attraction {
  id          String           @id @default(cuid())
  name        String
  city        String
  address     String?
  category    String?
  description String?          @db.Text
  images      String[]
  status      AttractionStatus @default(DRAFT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([city])
  @@index([status])
}

// --- OTA INVENTORY CALENDAR ---
// Date-based inventory per room, preventing overbooking with transactional updates.
model RoomInventory {
  id     String @id @default(cuid())
  roomId String

  // Stored as a date-only value in Postgres.
  date DateTime @db.Date

  // Total sellable inventory for that room on that date.
  total  Int
  // Already-reserved inventory for that room on that date.
  booked Int @default(0)

  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([roomId, date])
  @@index([date])
}

// --- PAYMENT (DEMO BUT REAL LOGIC) ---
enum PaymentStatus {
  PENDING
  PAID
  CANCELLED
}

model Payment {
  id        String @id @default(cuid())
  bookingId String @unique

  amount   Float
  currency String        @default("VND")
  method   String        @default("DEMO")
  status   PaymentStatus @default(PENDING)

  // Optional reference for future gateway integrations (kept for extensibility).
  providerRef String?

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

// --- POLICIES (DB-driven for AI explanations and enforcement) ---
model Policy {
  id String @id

  // Times are stored as "HH:mm" strings to keep it simple and DB-portable.
  checkInTime  String @default("14:00")
  checkOutTime String @default("12:00")

  // If cancellation happens within `cancellationDeadlineHours` before check-in,
  // refundPercent becomes 0 and cancellation may be blocked depending on UI flow.
  cancellationDeadlineHours Int @default(24)
  refundPercent             Int @default(100) // 0..100

  // Human-readable policy details for the AI assistant and UI.
  refundPolicyText String @db.Text

  // Cấu hình phí nghiệp vụ (dùng để tính giá trong OTA).
  serviceFeePercent Float @default(0)
  taxPercent        Float @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Flight {
  id            String          @id @default(cuid())
  airline       String
  flightNumber  String
  fromCity      String
  toCity        String
  departureTime DateTime
  arrivalTime   DateTime
  price         Float
  bookings      FlightBooking[]
}

model FlightBooking {
  id         String   @id @default(cuid())
  userId     String
  flightId   String
  totalPrice Float
  status     String   @default("CONFIRMED")
  user       User     @relation(fields: [userId], references: [id])
  flight     Flight   @relation(fields: [flightId], references: [id])
  createdAt  DateTime @default(now())
}

// 4. VOUCHER & SETTINGS
model Voucher {
  id          String   @id @default(cuid())
  code        String   @unique
  discount    Float
  type        String // PERCENT | AMOUNT
  description String?
  minSpend    Float?
  endDate     DateTime
  usageLimit  Int      @default(100)
  usedCount   Int      @default(0)

  users User[]
  bookings Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

}

model Settings {
  id              String  @id
  siteName        String
  contactEmail    String
  maintenanceMode Boolean @default(false)
}

model Review {
  id        String   @id @default(cuid())
  userId    String
  hotelId   String
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
}

// Bảng lưu cuộc hội thoại với AI
model AiConversation {
  id          String   @id @default(cuid())
  userId      String?
  userMessage String   @db.Text
  aiResponse  String   @db.Text
  createdAt   DateTime @default(now())
  
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([createdAt])
}

// Bảng đăng ký partner
enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

model PartnerApplication {
  id               String            @id @default(cuid())
  userId           String?           // Optional - có thể chưa có account
  
  // Thông tin liên hệ
  fullName         String
  position         String?
  email            String
  phone            String
  
  // Thông tin khách sạn
  hotelName        String
  city             String
  roomCount        Int?
  address          String
  website          String?
  
  // Thông tin kinh doanh
  businessLicense  String?
  taxCode          String?
  description      String?           @db.Text
  experience       String?
  notes            String?           @db.Text
  
  // Trạng thái đơn
  status           ApplicationStatus @default(PENDING)
  submittedAt      DateTime          @default(now())
  reviewedAt       DateTime?
  reviewedBy       String?           // Admin ID
  reviewNotes      String?           @db.Text
  
  user             User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([status])
  @@index([email])
  @@index([submittedAt])
}

// ============================================================================
// AI ASSISTANT - AUTO-EXECUTION MODELS
// ============================================================================

// User consent for auto-actions
model UserConsent {
  id     String @id @default(cuid())
  userId String @unique
  
  // Auto-action permissions
  autoBookingEnabled     Boolean @default(false)
  autoRoomHoldEnabled    Boolean @default(true)
  autoVoucherEnabled     Boolean @default(true)
  priceAlertsEnabled     Boolean @default(true)
  proactiveSuggestionsEnabled Boolean @default(true)
  
  // Limits
  maxAutoBookingAmount   Float   @default(3000000)
  
  // Consent tracking
  consentGivenAt DateTime @default(now())
  lastUpdated    DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

// Behavior patterns for proactive AI
model BehaviorPattern {
  id     String @id @default(cuid())
  userId String @unique
  
  // Travel frequency
  bookingsPerYear      Float   @default(0)
  lastBookingDate      DateTime?
  
  // Destination patterns
  favoriteDestinations Json    @default("[]")
  
  // Booking patterns
  avgBookingLeadTime   Int     @default(14)
  avgStayDuration      Int     @default(2)
  avgPricePerNight     Float   @default(0)
  
  // Preferences (learned)
  preferredHotelTypes  String[]
  preferredAmenities   String[]
  
  // Viewing behavior
  avgTimeOnHotel       Int     @default(0)
  hotelsViewedPerBooking Int   @default(5)
  viewingToBookingRate Float   @default(0.2)
  
  // Prediction scores
  priceSensitivity     Float   @default(0.5)
  impulseBuyer         Float   @default(0.3)
  plannerType          Float   @default(0.5)
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  updatedAt DateTime @updatedAt
  
  @@index([userId])
}

// Room holds for auto-holding
model RoomHold {
  id     String @id @default(cuid())
  roomId String
  userId String
  
  heldAt    DateTime @default(now())
  expiresAt DateTime
  
  status String @default("active")
  
  // Conversion tracking
  convertedToBookingId String?
  
  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([roomId])
  @@index([expiresAt])
  @@index([status])
}

// Proactive suggestions queue
model ProactiveSuggestion {
  id     String @id @default(cuid())
  userId String
  
  type     String
  priority String @default("medium")
  
  message  String
  actionType String?
  actionData Json?
  
  // Delivery tracking
  status      String   @default("pending")
  deliveredAt DateTime?
  actedAt     DateTime?
  
  // Expiration
  expiresAt DateTime?
  
  // Reasoning
  reasoning String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@index([userId, status])
  @@index([priority])
  @@index([expiresAt])
}

// Price monitoring for alerts
model PriceWatch {
  id       String @id @default(cuid())
  userId   String
  hotelId  String
  
  // Watch criteria
  targetPrice    Float?
  alertOnAnyDrop Boolean @default(true)
  minDropPercent Float   @default(10)
  
  // Current state
  lastKnownPrice Float
  lastChecked    DateTime @default(now())
  
  // Alert tracking
  alertsSent     Int      @default(0)
  lastAlertSent  DateTime?
  
  active Boolean @default(true)
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  hotel Hotel @relation(fields: [hotelId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@index([userId, active])
  @@index([hotelId])
  @@index([lastChecked])
}

// Auto-executed actions log
model AutoActionLog {
  id     String @id @default(cuid())
  userId String
  
  actionType String
  status     String
  
  // Action details
  actionData Json
  result     Json?
  
  // Execution metrics
  executionTime Int
  
  // User feedback
  userFeedback String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@index([userId, createdAt])
  @@index([actionType])
  @@index([status])
}

// User profile for AI personalization
model UserProfile {
  id     String @id @default(cuid())
  userId String @unique
  
  // Explicit preferences
  favoriteLocations    String[]
  budgetMin            Float?
  budgetMax            Float?
  preferredRoomTypes   String[]
  preferredAmenities   String[]
  travelCompanions     Int      @default(2)
  travelFrequency      String?
  
  // Inferred preferences
  inferredBudget       Float?
  preferredSeasons     String[]
  hotelTypePreference  String?
  avgBookingLeadTime   Int?
  avgStayDuration      Int?
  
  // Privacy settings
  personalizationEnabled Boolean @default(true)
  dataCollectionConsent  Boolean @default(false)
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId])
}

// Track user interactions for learning
model UserInteraction {
  id     String @id @default(cuid())
  userId String
  
  interactionType String
  entityType      String?
  entityId        String?
  
  // Context
  duration Int?
  
  metadata Json?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@index([userId, createdAt])
  @@index([interactionType])
}

// Price history for prediction
model PriceHistory {
  id     String @id @default(cuid())
  roomId String
  
  date  DateTime @db.Date
  price Float
  
  // Context for price changes
  dayOfWeek    Int
  isWeekend    Boolean
  isHoliday    Boolean
  seasonalFlag String?
  
  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@unique([roomId, date])
  @@index([roomId, date])
}

// AI conversation sessions
model ConversationSession {
  id        String @id @default(cuid())
  userId    String?
  sessionId String @unique
  
  // Session state
  stage         String
  extractedInfo Json
  
  // Metadata
  startedAt  DateTime @default(now())
  lastActive DateTime @default(now())
  endedAt    DateTime?
  
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([sessionId])
  @@index([lastActive])
}

// ============================================================================
// ENTERPRISE AUTONOMOUS AI SYSTEM
// ============================================================================

// AI Delegation Settings - User authorizes AI to execute actions
model AIDelegation {
  id     String @id @default(cuid())
  userId String @unique

  // Delegation permissions
  canPlaceBookings    Boolean @default(false)
  canCancelBookings   Boolean @default(false)
  canOptimizeRefunds  Boolean @default(false)
  canRebookForPolicy  Boolean @default(false)

  // Limits
  maxBudgetPerBooking Float?
  cancellationTimeWindow Int? // hours before check-in
  refundThreshold Float? // minimum refund % to auto-cancel

  // Audit
  enabled   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Draft Booking - AI prepares booking before execution
model DraftBooking {
  id String @id @default(cuid())
  userId String

  // Booking details
  hotelId   String
  roomId    String
  checkIn   DateTime @db.Date
  checkOut  DateTime @db.Date
  guests    Int
  totalPrice Float

  // AI reasoning
  intentType String // business, leisure, honeymoon, family, emergency
  matchedTags String[] // businessTags that matched
  optimizationScore Float // 0-1, how good this option is
  reasoning String @db.Text // why AI selected this

  // Status
  status String @default("PREPARED") // PREPARED, CONFIRMED, EXPIRED, REJECTED
  expiresAt DateTime // drafts expire after 24h

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  hotel Hotel @relation(fields: [hotelId], references: [id])
  room  Room  @relation(fields: [roomId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status])
  @@index([expiresAt])
}

// Draft Cancellation - AI prepares cancellation with refund analysis
model DraftCancellation {
  id String @id @default(cuid())
  userId String
  bookingId String

  // Refund analysis
  estimatedRefund Float
  refundPercentage Float
  policyType String // flexible, moderate, strict
  optimalCancelTime DateTime? // best time to cancel for max refund

  // AI reasoning
  reasoning String @db.Text
  riskLevel String // low, medium, high
  recommendation String // CANCEL_NOW, WAIT, DONT_CANCEL

  // Status
  status String @default("PREPARED") // PREPARED, EXECUTED, EXPIRED, REJECTED
  expiresAt DateTime

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  booking Booking @relation(fields: [bookingId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status])
  @@index([bookingId])
}

// AI Task Log - Audit trail for all AI actions
model AITaskLog {
  id String @id @default(cuid())
  userId String?

  // Task details
  taskType String // PREPARE_BOOKING, EXECUTE_BOOKING, PREPARE_CANCELLATION, etc.
  intent String // business, leisure, honeymoon, family, emergency
  inputData Json // structured input from UI
  outputData Json // AI result

  // Execution
  status String // SUCCESS, FAILED, PARTIAL
  executionTime Int // milliseconds
  wasDelegated Boolean @default(false)
  wasAutoExecuted Boolean @default(false)

  // Audit
  errorMessage String?
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([taskType])
  @@index([wasDelegated])
}
